interface OpenAIResponse {
  response: string;
  confidence: number;
  reasoning: string;
}

interface OpenAIError {
  error: string;
  code?: string;
  shouldFallback: boolean;
}

/**
 * OpenAI Service for handling complex or emotional queries that can't be resolved
 * through rule-based logic. This acts as a fallback for empathetic, nuanced responses.
 */
class OpenAIService {
  private apiKey: string | null = null;
  private baseURL = 'https://api.openai.com/v1/chat/completions';
  private cache = new Map<string, { response: OpenAIResponse; timestamp: number }>();
  private readonly cacheTimeout = 5 * 60 * 1000; // 5 minutes

  constructor() {
    // In a real application, this would come from environment variables
    // For demo purposes, this can be set manually or through a config
    this.apiKey = (import.meta as any).env?.VITE_OPENAI_API_KEY || null;
  }

  /**
   * Determines if a query should be sent to OpenAI based on sentiment and complexity
   */
  shouldUseAI(query: string, sentimentAnalysis: any, hasRuleBasedResponse: boolean): boolean {
    // Don't use AI if no API key is configured
    if (!this.apiKey) {
      return false;
    }

    // Use AI for highly emotional or complex queries
    const emotionalStates = ['angry', 'frustrated', 'worried', 'sad'];
    const isHighlyEmotional = emotionalStates.includes(sentimentAnalysis.emotion) && 
                             sentimentAnalysis.confidence > 0.7;

    // Use AI for complex language patterns
    const isComplex = query.length > 100 || 
                     query.includes('?') && query.split('?').length > 2 ||
                     /why|how|what if|explain|understand|confused|help me/.test(query.toLowerCase());

    // Use AI if sentiment is very negative and we have a weak rule-based response
    const isVeryNegative = sentimentAnalysis.sentiment === 'very-negative' && 
                          sentimentAnalysis.urgency === 'urgent';

    // Use AI for ambiguous queries where rule-based response might be inadequate
    const queryLower = query.toLowerCase();
    const isAmbiguous = !hasRuleBasedResponse || 
                       queryLower.includes('not sure') ||
                       queryLower.includes('confused') ||
                       queryLower.includes('don\'t understand');

    return isHighlyEmotional || (isComplex && isVeryNegative) || isAmbiguous;
  }

  /**
   * Generates an AI response for complex or emotional queries
   */
  async generateAIResponse(
    query: string, 
    transaction: any, 
    sentimentAnalysis: any,
    context: string = ''
  ): Promise<OpenAIResponse | OpenAIError> {
    if (!this.apiKey) {
      return {
        error: 'OpenAI API key not configured',
        shouldFallback: true
      };
    }

    // Check cache first
    const cacheKey = this.generateCacheKey(query, transaction.booking_id);
    const cached = this.cache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
      return cached.response;
    }

    try {
      const systemPrompt = this.createSystemPrompt(transaction, sentimentAnalysis);
      const userMessage = this.createUserMessage(query, context);

      const response = await fetch(this.baseURL, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: 'gpt-3.5-turbo',
          messages: [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: userMessage }
          ],
          max_tokens: 300,
          temperature: 0.7,
          presence_penalty: 0.1,
          frequency_penalty: 0.1
        })
      });

      if (!response.ok) {
        throw new Error(`OpenAI API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      const aiResponse: OpenAIResponse = {
        response: data.choices[0]?.message?.content || 'I apologize, but I\'m having trouble generating a response right now.',
        confidence: 0.8, // AI responses generally have high confidence
        reasoning: 'Generated by OpenAI for complex/emotional query'
      };

      // Cache the response
      this.cache.set(cacheKey, { response: aiResponse, timestamp: Date.now() });

      return aiResponse;

    } catch (error) {
      console.error('OpenAI API Error:', error);
      
      return {
        error: error instanceof Error ? error.message : 'Unknown OpenAI error',
        code: 'OPENAI_ERROR',
        shouldFallback: true
      };
    }
  }

  /**
   * Creates a system prompt that gives the AI context about the user and situation
   */
  private createSystemPrompt(transaction: any, sentimentAnalysis: any): string {
    return `You are an empathetic airline customer service assistant. The user seems ${sentimentAnalysis.emotion} and their message has ${sentimentAnalysis.sentiment} sentiment with ${sentimentAnalysis.urgency} urgency.

CUSTOMER INFO:
- Booking ID: ${transaction.booking_id}
- Flight: ${transaction.flight_number} from ${transaction.departure_airport} to ${transaction.arrival_airport}
- Departure: ${transaction.departure_time}
- Status: ${transaction.status}
- Refund Status: ${transaction.refund_id ? `Active (${transaction.refund_status})` : 'None'}

RESPONSE GUIDELINES:
- Be warm, empathetic, and human-like
- Address their emotional state appropriately
- Keep responses under 200 words
- Provide actionable next steps when possible
- If you can't solve the issue, direct them to appropriate support channels
- Use natural, conversational language - not robotic corporate speak
- Acknowledge their frustration/concern genuinely

TONE ADJUSTMENT:
- ${sentimentAnalysis.emotion === 'angry' ? 'Apologetic and solution-focused' : ''}
- ${sentimentAnalysis.emotion === 'worried' ? 'Reassuring and calming' : ''}
- ${sentimentAnalysis.emotion === 'frustrated' ? 'Understanding and proactive' : ''}
- ${sentimentAnalysis.urgency === 'urgent' ? 'Immediate and action-oriented' : ''}

Remember: You're talking to a real person with real concerns. Be human, not a robot.`;
  }

  /**
   * Creates the user message for the AI
   */
  private createUserMessage(query: string, context: string): string {
    return context ? `Context: ${context}\n\nUser Query: ${query}` : query;
  }

  /**
   * Generates a cache key for storing responses
   */
  private generateCacheKey(query: string, bookingId: string): string {
    // Simple hash function for caching
    const normalizedQuery = query.toLowerCase().trim().replace(/[^\w\s]/g, '');
    return `${bookingId}_${normalizedQuery.substring(0, 50)}`;
  }

  /**
   * Clears expired cache entries
   */
  private clearExpiredCache(): void {
    const now = Date.now();
    for (const [key, value] of this.cache.entries()) {
      if (now - value.timestamp > this.cacheTimeout) {
        this.cache.delete(key);
      }
    }
  }

  /**
   * Gets cache statistics for debugging
   */
  getCacheStats(): { size: number; hitRate: number } {
    this.clearExpiredCache();
    return {
      size: this.cache.size,
      hitRate: 0 // Would need to track hits/misses for accurate calculation
    };
  }
}

// Export singleton instance
export const openAIService = new OpenAIService();

// Export types for use in other modules
export type { OpenAIResponse, OpenAIError };
